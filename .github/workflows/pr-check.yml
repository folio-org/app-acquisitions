name: Application Check

run-name: >-
  Application Check • PR #${{ inputs.pr_number }}

on:
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'Pull request number'
        required: true
        type: string
      head_sha:
        description: 'Head commit SHA that triggered the check suite'
        required: true
        type: string

permissions:
  contents: read
  checks: write
  statuses: write

jobs:
  pre-check:
    name: Pre-Check Configuration
    runs-on: ubuntu-latest
    outputs:
      validation_status: ${{ steps.validate.outputs.status }}
      validation_message: ${{ steps.validate.outputs.message }}
      check_run_id: ${{ steps.create-check.outputs.check_run_id }}
      head_sha: ${{ steps.pr-info.outputs.head_sha }}
      head_branch: ${{ steps.pr-info.outputs.head_ref }}
      base_branch: ${{ steps.pr-info.outputs.base_ref }}
    steps:
      - name: Get Pull Request Information
        id: pr-info
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const prNumberInput = '${{ inputs.pr_number }}';

            // Validate PR number input
            if (!prNumberInput || prNumberInput === '0' || prNumberInput === '') {
              console.log('No valid PR number provided, skipping checks');
              core.setOutput('pr_exists', 'false');
              core.setOutput('skip_reason', 'No PR number provided');
              return;
            }

            const prNumber = parseInt(prNumberInput);

            if (isNaN(prNumber) || prNumber <= 0) {
              console.log(`Invalid PR number: ${prNumberInput}`);
              core.setOutput('pr_exists', 'false');
              core.setOutput('skip_reason', `Invalid PR number: ${prNumberInput}`);
              return;
            }

            console.log(`Fetching PR #${prNumber} from ${{ github.repository }}`);

            try {
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });

              const labels = pr.labels.map(l => l.name);

              console.log(`PR #${prNumber} Details:`);
              console.log(`  Title: ${pr.title}`);
              console.log(`  State: ${pr.state}`);
              console.log(`  Base: ${pr.base.ref}`);
              console.log(`  Head: ${pr.head.ref}`);
              console.log(`  Current SHA: ${pr.head.sha}`);
              console.log(`  Labels: ${labels.join(', ') || 'none'}`);

              core.setOutput('pr_exists', 'true');
              core.setOutput('current_head_sha', pr.head.sha);
              core.setOutput('head_ref', pr.head.ref);
              core.setOutput('base_ref', pr.base.ref);
              core.setOutput('labels', JSON.stringify(labels));
              core.setOutput('state', pr.state);

            } catch (error) {
              console.log(`Failed to fetch PR #${prNumber}: ${error.message}`);
              core.setOutput('pr_exists', 'false');
              core.setOutput('skip_reason', `PR #${prNumber} not found or inaccessible`);
            }

      - name: Validate Commit in PR
        id: validate-commit
        if: steps.pr-info.outputs.pr_exists == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const prNumber = parseInt('${{ inputs.pr_number }}');
            const providedSha = '${{ inputs.head_sha }}';

            console.log(`Validating that commit ${providedSha} exists in PR #${prNumber}`);

            try {
              let shaFound = false;
              let page = 1;
              const perPage = 100;

              // GitHub API paginates commits, so we need to check all pages
              while (!shaFound) {
                const { data: commits } = await github.rest.pulls.listCommits({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                  per_page: perPage,
                  page: page
                });

                if (commits.length === 0) {
                  break; // No more commits
                }

                console.log(`Checking page ${page}: ${commits.length} commits`);

                // Check if our SHA is in this batch
                shaFound = commits.some(commit => {
                  // Check both full SHA and short SHA
                  return commit.sha === providedSha ||
                         commit.sha.startsWith(providedSha) ||
                         providedSha.startsWith(commit.sha);
                });

                if (shaFound) {
                  console.log(`✓ Found commit ${providedSha} on page ${page}`);
                  break;
                }

                // If we got fewer commits than requested, we've reached the end
                if (commits.length < perPage) {
                  break;
                }

                page++;
              }

              if (!shaFound) {
                console.log(`Error: Commit ${providedSha} not found in PR #${prNumber}`);
                console.log(`This commit does not belong to this PR`);
                core.setOutput('commit_valid', 'false');
                core.setOutput('skip_reason', `Commit ${providedSha} not found in PR #${prNumber}`);
                return;
              }

              console.log(`✓ Confirmed: Commit ${providedSha} exists in PR #${prNumber}`);
              core.setOutput('commit_valid', 'true');

            } catch (error) {
              console.log(`Failed to verify commit: ${error.message}`);
              core.setOutput('commit_valid', 'false');
              core.setOutput('skip_reason', `Failed to verify commit: ${error.message}`);
            }

      - name: Checkout Repository
        if: steps.pr-info.outputs.pr_exists == 'true' && steps.validate-commit.outputs.commit_valid == 'true'
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.head_sha }}

      - name: Get Release Configuration
        id: get-config
        if: steps.pr-info.outputs.pr_exists == 'true' && steps.validate-commit.outputs.commit_valid == 'true'
        uses: folio-org/kitfox-github/.github/actions/get-release-config@master
        with:
          repo: ${{ github.repository }}
          branch: ${{ github.ref_name }}
          github_token: ${{ github.token }}

      - name: Validate Configuration
        id: validate
        if: steps.pr-info.outputs.pr_exists == 'true' && steps.validate-commit.outputs.commit_valid == 'true'
        env:
          TARGET_BRANCH: ${{ steps.pr-info.outputs.base_ref }}
          PR_LABELS: ${{ steps.pr-info.outputs.labels }}
          CONFIG_EXISTS: ${{ steps.get-config.outputs.config_exists }}
          ENABLED: ${{ steps.get-config.outputs.enabled }}
          RELEASE_BRANCHES: ${{ steps.get-config.outputs.release_branches }}
          REQUIRED_LABELS: ${{ steps.get-config.outputs.pr_labels }}
        run: |
          echo "::notice::Validating configuration for branch $TARGET_BRANCH"

          if [[ "$CONFIG_EXISTS" != "true" ]]; then
            echo "status=skipped" >> "$GITHUB_OUTPUT"
            echo "message=Release configuration file not found" >> "$GITHUB_OUTPUT"
            echo "::warning::Configuration file not found: .github/release-config.yml"
            exit 0
          fi

          if [[ "$ENABLED" != "true" ]]; then
            echo "status=skipped" >> "$GITHUB_OUTPUT"
            echo "message=Release scanning is disabled in configuration" >> "$GITHUB_OUTPUT"
            echo "::notice::Release scanning is disabled"
            exit 0
          fi

          BRANCH_EXISTS=$(echo "$RELEASE_BRANCHES" | jq -r ".[] | select(. == \"$TARGET_BRANCH\")" 2>/dev/null)
          if [ -z "$BRANCH_EXISTS" ]; then
            echo "status=skipped" >> "$GITHUB_OUTPUT"
            echo "message=Target branch $TARGET_BRANCH is not configured for release scanning" >> "$GITHUB_OUTPUT"
            echo "::notice::Branch $TARGET_BRANCH is not in release_branches configuration"
            exit 0
          fi

          if [ -n "$REQUIRED_LABELS" ]; then
            echo "::notice::Checking for required labels: $REQUIRED_LABELS"
            PR_LABELS_ARRAY=$(echo "$PR_LABELS" | jq -r '.[]' 2>/dev/null || echo "")
            MISSING_LABELS=""

            # Convert comma-separated labels to array
            IFS=',' read -ra LABEL_ARRAY <<< "$REQUIRED_LABELS"
            for label in "${LABEL_ARRAY[@]}"; do
              label=$(echo "$label" | xargs) # Trim whitespace
              if ! echo "$PR_LABELS_ARRAY" | grep -q "^$label$"; then
                MISSING_LABELS="${MISSING_LABELS}${MISSING_LABELS:+, }$label"
              fi
            done

            if [ -n "$MISSING_LABELS" ]; then
              echo "status=skipped" >> "$GITHUB_OUTPUT"
              echo "message=PR is missing required labels: $MISSING_LABELS" >> "$GITHUB_OUTPUT"
              echo "::notice::PR does not have required labels, skipping validation"
              exit 0
            fi
          fi

          echo "status=success" >> "$GITHUB_OUTPUT"
          echo "message=Configuration validation passed" >> "$GITHUB_OUTPUT"
          echo "::notice::Configuration validation successful"

      - name: Generate GitHub App Token
        id: app-token
        if: steps.pr-info.outputs.pr_exists == 'true' && steps.validate-commit.outputs.commit_valid == 'true' && steps.validate.outputs.status == 'success'
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ vars.EUREKA_CI_APP_ID }}
          private-key: ${{ secrets.EUREKA_CI_APP_KEY }}
          owner: ${{ github.repository_owner }}
          repositories: ${{ github.repository }}

      - name: Create Check Run
        id: create-check
        if: steps.pr-info.outputs.pr_exists == 'true' && steps.validate-commit.outputs.commit_valid == 'true' && steps.validate.outputs.status == 'success'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const { data: checkRun } = await github.rest.checks.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              name: 'Application Verification',
              head_sha: '${{ inputs.head_sha }}',
              status: 'in_progress',
              started_at: new Date().toISOString(),
              output: {
                title: 'Application Verification',
                summary: 'Verifying application configuration and dependencies for PR #${{ inputs.pr_number }}...'
              },
              details_url: `https://github.com/${{ github.repository }}/pull/${{ inputs.pr_number }}`
            });

            console.log(`Created check run with ID: ${checkRun.id}`);
            core.setOutput('check_run_id', checkRun.id);

  generate-descriptor:
    name: Generate Application Descriptor
    needs: pre-check
    if: needs.pre-check.outputs.validation_status == 'success'
    runs-on: ubuntu-latest
    outputs:
      generated: ${{ steps.generate.outputs.generated }}
      descriptor_file: ${{ steps.generate.outputs.descriptor_file }}
      descriptor_file_name: ${{ steps.generate.outputs.descriptor_file_name }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.head_sha }}

      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ vars.EUREKA_CI_APP_ID }}
          private-key: ${{ secrets.EUREKA_CI_APP_KEY }}
          owner: ${{ github.repository_owner }}
          repositories: ${{ github.repository }}

      - name: Update Check Run - Generating
        if: needs.pre-check.outputs.check_run_id != ''
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            await github.rest.checks.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              check_run_id: ${{ needs.pre-check.outputs.check_run_id }},
              status: 'in_progress',
              output: {
                title: 'Application Verification',
                summary: 'Step 2/3: Generating application descriptor...'
              }
            });

      - name: Generate Application Descriptor
        id: generate
        uses: folio-org/kitfox-github/.github/actions/generate-application-descriptor@RANCHER-2323-test
        with:
          app_name: ${{ github.event.repository.name }}
          state_file: 'application-descriptor.json'
          upload_artifact: 'true'

  verify-application:
    name: Verify Application
    needs: [pre-check, generate-descriptor]
    if: needs.pre-check.outputs.validation_status == 'success' && needs.generate-descriptor.outputs.generated == 'true'
    uses: folio-org/kitfox-github/.github/workflows/verify-application.yml@RANCHER-2323-test
    with:
      app_name: ${{ github.event.repository.name }}
      app_descriptor_file: ${{ needs.generate-descriptor.outputs.descriptor_file }}
      app_descriptor_file_name: ${{ needs.generate-descriptor.outputs.descriptor_file_name }}
      rely_on_FAR: false
      skip_upload: true
    secrets: inherit

  finalize-check:
    name: Finalize Check Run
    needs: [pre-check, generate-descriptor, verify-application]
    if: always() && needs.pre-check.outputs.check_run_id != ''
    runs-on: ubuntu-latest
    steps:
      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ vars.EUREKA_CI_APP_ID }}
          private-key: ${{ secrets.EUREKA_CI_APP_KEY }}
          owner: ${{ github.repository_owner }}
          repositories: ${{ github.repository }}

      - name: Determine Final Status
        id: status
        env:
          VALIDATION_STATUS: ${{ needs.pre-check.outputs.validation_status }}
          VALIDATION_MESSAGE: ${{ needs.pre-check.outputs.validation_message }}
          DESCRIPTOR_GENERATED: ${{ needs.generate-descriptor.outputs.generated }}
          VERIFICATION_RESULT: ${{ needs.verify-application.result }}
        run: |
          if [[ "$DESCRIPTOR_GENERATED" != "true" ]]; then
            echo "conclusion=failure" >> "$GITHUB_OUTPUT"
            echo "title=Descriptor Generation Failed" >> "$GITHUB_OUTPUT"
            echo "summary=Failed to generate application descriptor" >> "$GITHUB_OUTPUT"
          elif [[ "$VERIFICATION_RESULT" == "failure" ]]; then
            echo "conclusion=failure" >> "$GITHUB_OUTPUT"
            echo "title=Verification Failed" >> "$GITHUB_OUTPUT"
            echo "summary=Application verification failed. Check the logs for details." >> "$GITHUB_OUTPUT"
          elif [[ "$VERIFICATION_RESULT" == "success" ]]; then
            echo "conclusion=success" >> "$GITHUB_OUTPUT"
            echo "title=All Checks Passed" >> "$GITHUB_OUTPUT"
            echo "summary=Application verification completed successfully" >> "$GITHUB_OUTPUT"
          else
            echo "conclusion=neutral" >> "$GITHUB_OUTPUT"
            echo "title=Check Incomplete" >> "$GITHUB_OUTPUT"
            echo "summary=Some checks could not be completed" >> "$GITHUB_OUTPUT"
          fi

      - name: Update Check Run - Final
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const text = `
            ## Application Verification Results

            **Branch:** \`${{ needs.pre-check.outputs.head_branch }}\`
            **Commit:** \`${{ needs.pre-check.outputs.head_sha }}\`
            **Pull Request:** [#${{ inputs.pr_number }}](https://github.com/${{ github.repository }}/pull/${{ inputs.pr_number }})

            ### Validation Status
            - **Result:** ${{ needs.pre-check.outputs.validation_status || 'unknown' }}
            - **Message:** ${{ needs.pre-check.outputs.validation_message || 'No message' }}

            ### Descriptor Generation
            - **Generated:** ${{ needs.generate-descriptor.outputs.generated || 'false' }}

            ### Application Verification
            - **Result:** ${{ needs.verify-application.result || 'skipped' }}

            ### Workflow Run
            - **Run ID:** ${{ github.run_id }}
            - **Run Number:** ${{ github.run_number }}
            - **Run URL:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
            `;

            await github.rest.checks.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              check_run_id: ${{ needs.pre-check.outputs.check_run_id }},
              status: 'completed',
              conclusion: '${{ steps.status.outputs.conclusion }}',
              completed_at: new Date().toISOString(),
              output: {
                title: '${{ steps.status.outputs.title }}',
                summary: '${{ steps.status.outputs.summary }}',
                text: text
              },
              details_url: '${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}'
            });

  notify:
    name: Send Notifications
    needs: [pre-check, generate-descriptor, verify-application]
    if: always() && !cancelled() && needs.pre-check.outputs.validation_status == 'success'
    runs-on: ubuntu-latest
    env:
      TITLE_TEXT: "${{ github.event.repository.name }} release update check ${{ needs.verify-application.result == 'success' && 'passed' || 'failed' }}"
      TITLE_BLOCK: |
        {
          "type": "section",
          "text": {
            "type": "mrkdwn",
            "text": "*${{ github.event.repository.name }} release update check ${{ needs.verify-application.result == 'success' && 'passed' || 'failed' }} <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|#${{ github.run_number }}>*"
          }
        }
    steps:
      - name: Send to General Channel
        if: vars.GENERAL_SLACK_NOTIF_CHANNEL != ''
        continue-on-error: true
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.postMessage
          token: ${{ secrets.EUREKA_CI_SLACK_BOT_TOKEN }}
          errors: false
          payload: |
            {
              "channel": "${{ vars.GENERAL_SLACK_NOTIF_CHANNEL }}",
              "text": "${{ env.TITLE_TEXT }}",
              "blocks": [
                ${{ env.TITLE_BLOCK }}
              ],
              "attachments": [
                {
                  "color": "${{ needs.verify-application.result == 'success' && 'good' || 'danger' }}",
                  "fields": [
                    {
                      "title": "Release branch",
                      "value": "${{ needs.pre-check.outputs.base_branch }}",
                      "short": true
                    },
                    {
                      "title": "Update branch",
                      "value": "${{ needs.pre-check.outputs.head_branch }}",
                      "short": true
                    },
                    {
                      "title": "PR Number",
                      "value": "<https://github.com/${{ github.repository }}/pull/${{ inputs.pr_number }}|#${{ inputs.pr_number }}>",
                      "short": true
                    },
                    {
                      "title": "Commit",
                      "value": "<https://github.com/${{ github.repository }}/commit/${{ inputs.head_sha }}|${{ inputs.head_sha }}>",
                      "short": true
                    }            
                  ],
                  "footer": "Eureka CI/CD"
                }
              ]
            }